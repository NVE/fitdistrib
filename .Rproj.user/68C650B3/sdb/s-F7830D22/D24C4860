{
    "contents" : "# GEV.R\n# All functions related to fitting the Generalized Extreme Value distribution\n# All distribution functions names are \"distrib_method\"\n\n#' Fitting the GEV distribution with MLE\n#' @description Function to fit the GEV distribution with the maximum likelihood method\n#' @param dat the data that needs fitting (i.e. flood data)\n#' @return param Estimated parameters and standard error returned as a list($estimate, $se)\n#' @export\n#'\n#' @examples gev_mle(evd::rgev(10000, loc=0, scale=1, shape=0))\ngev_mle <- function(dat) {\n\n  param <- list(estimate = c(NA, NA, NA), se = c(NA, NA, NA))\n  if (length(dat) >= GLOBAL_min_years_data) {\n\n\n    fail_safe <- plyr::failwith(NULL, evd::fgev)\n    fitted.param <- fail_safe(dat)\n\n    if (is.null(fitted.param) == TRUE) {\n      print(\"Warning: the function fgev failed in gev_mle\")\n      invisible(param)\n    } else {\n    # fitted.param <- fgev(dat)\n    param$estimate <- fitted.param$estimate\n    param$se <- fitted.param$std.err\n    invisible(param)\n    }\n    } else {\n      print(paste(\"Warning: this station has less than \", GLOBAL_min_years_data,\" years of data. Use another method!\",\n                  collapse = \"\", sep = \"\"))\n      invisible(param)\n    }\n}\n\n#' Fitting the GEV distribution with Lmom\n#' @description Function to fit the GEV distribution with the linear moment method\n#' @param dat the data that needs fitting (i.e. flood data)\n#' @return param Estimated parameters and standard error returned as a list($estimate, $se).\n#' Standard error is not yet implemented\n#' @export\n#'\n#' @examples gev_Lmom(evd::rgev(10000, loc=0, scale=1, shape=0))\ngev_Lmom <- function(dat) {\n\n  param <- list(estimate = c(NA, NA, NA), se = c(NA, NA, NA))\n  if (length(dat) >= GLOBAL_min_years_data) {\n\n    dat.Lmom <- nsRFA::Lmoments(dat)\n\n\n    fail_safe <- dplyr::failwith(NULL, nsRFA::par.GEV)\n    fitted.param <- fail_safe(dat.Lmom[1], dat.Lmom[2], dat.Lmom[4])\n\n    if (is.null(fitted.param) == TRUE) {\n      print(\"Warning: the function par.GEV failed in gev_Lmom\")\n      invisible(param)\n    } else {\n    # fitted.param <- as.numeric(par.GEV(dat.mom[1], dat.mom[2], dat.mom[4]))\n    # Creating the returning list\n    param$estimate <- c(fitted.param$xi, fitted.param$alfa, - fitted.param$k)\n    # Standard error is not yet implemented\n    invisible(param)\n    }\n  } else {\n    print(paste(\"Warning: this station has less than \", GLOBAL_min_years_data,\" years of data. Use another method!\",\n                  collapse = \"\", sep = \"\"))\n    invisible(param)\n  }\n}\n\n#' Fitting the GEV distribution with mom\n#' @description Function to fit the GEV distribution with the ordinary moments method\n#' @param dat the data that needs fitting (i.e. flood data)\n#' @return param Estimated parameters and standard error returned as a list($estimate, $se)\n#' Standard error is not yet implemented\n#' @export\n#'\n#' @examples gev_mom(evd::rgev(10000, loc=0, scale=1, shape=0))\ngev_mom <- function(dat) {\n\n  param <- list(estimate = c(NA, NA, NA), se = c(NA, NA, NA))\n  if (length(dat) >= GLOBAL_min_years_data) {\n\n  gevmom <- nsRFA::moments(dat)\n  # print(gevmom)\n  kfunc <- function(k) {\n    # print(k)\n    if (abs(k) > 0.00000001) {\n      sign(k) * ((-1) * gamma(1+3*k) + 3*gamma(1 + k) * gamma(1 + 2*k) - 2*(gamma(1 + k))^3)/\n        ((gamma(1 + 2*k) - (gamma(1 + k))^2)^(3/2)) - as.numeric(gevmom[4])\n    } else {\n      (12*sqrt(6) * zeta(3)) / (pi^3) - as.numeric(gevmom[4])\n    }\n  }\n  # xi <- newtonRaphson(kfunc, -0.1, tol = 0.0001)$root  # FKB: initial code\n  fail_safe <- dplyr::failwith(NULL, pracma::newtonRaphson)  # START FKB HACK\n  xi <- fail_safe(kfunc, -0.1, tol = 0.0001)\n  xi <- xi$root\n\n  if (is.null(xi) == TRUE) {\n    print(\"Warning: the function newtonRaphson failed in gev_mom\")   # PB WITH locp!!\n    invisible(param)\n  } else {\n\n      if (xi == 0) {   # END FKB HACK\n      # xi <- xi$root\n      scp = (as.numeric(gevmom[2]) * sqrt(6)) / (pi)\n      locp = as.numeric(gevmom[1]) - as.numeric(gevmom[2]) * 0.57721566490\n      } else {\n      # xi <- xi$root\n      scp = (as.numeric(gevmom[2])*abs(xi))/sqrt((gamma(1+2*xi)-(gamma(1+xi))^2))\n      locp = as.numeric(gevmom[1])-(scp/xi)*(1-gamma(1+xi))\n      }\n  # z <- list()   # commented FKB\n  # z$dat <- dat  # commented FKB\n  # z$mle replaced by z$estimate to integrate with the other functions\n  param$estimate <- c(locp, scp, (-1)*xi)  # z replaced by param FKB\n  # z$vals <- cbind(locp, scp, xi) # commented FKB\n  # class(z) <- \"gev.fit\"\n  # Standard error is not yet implemented\n  invisible(param)\n  }\n  } else {\n    print(paste(\"Warning: this station has less than \", GLOBAL_min_years_data,\" years of data. Use another method!\",\n                  collapse = \"\",sep = \"\"))\n    invisible(param)\n    }\n}\n\n#' Fitting the GEV distribution with Bayesian inference\n#' @description Function to fit the GEV distribution with BayesianMCMC method\n#' WE assume that the shape parameter only has a prior with mean zero and standard deviation 0.2 (dnorm(x[3], 0, 0.2))\n#' @param dat the data that needs fitting (i.e. flood data)\n#' @return param Estimated parameters and standard error returned as a list($estimate, $se)\n#' @export\n#'\n#' @examples gev_bayes(evd::rgev(10000, loc=0, scale=1, shape=0))\ngev_bayes <- function(dat) {\n\n  param <- list(estimate = c(NA, NA, NA), se = c(NA, NA, NA))\n\n  if (length(dat) >= GLOBAL_min_years_data) {\n    # Prior for Bayes\n    myprior <- function (x) {\n      # x = vector of parameter values: c(location, scale, shape)\n      # I assume the shape parameter only has a prior with mean zero and standard deviation 0.2\n      dnorm(x[3], 0, 0.2)\n    }\n\n    fail_safe <- dplyr::failwith(NULL, nsRFA::BayesianMCMC)\n    bayes <- fail_safe(dat, nbpas = 5000, nbchaines = 3, confint = c(0.05, 0.95), dist = \"GEV\", apriori = myprior)\n\n    if (is.null(bayes) == TRUE) {\n      print(\"Warning: the function BayesianMCMC failed in gev_bayes\")\n      invisible(param)\n    } else {\n\n      ## Addition to return parameters\n        # Solution 1\n      param$estimate <- bayes$parametersML\n      # Sign correction for the shape parameter to be consistent with the other fitting functions\n      param$estimate[3] <- - param$estimate[3]\n\n      # Solution 2\n#       param$estimate[1] <- mean(as.vector(bayes$parameters[, 1, 1:3]))\n#       param$estimate[2] <- mean(as.vector(bayes$parameters[, 2, 1:3]))\n#       param$estimate[3] <- mean(as.vector(bayes$parameters[, 3, 1:3]))\n\n      param$se[1] <- sd(as.vector(bayes$parameters[ , 1, 1:3]))\n      param$se[2] <- sd(as.vector(bayes$parameters[ , 2, 1:3]))\n      param$se[3] <- sd(as.vector(bayes$parameters[ , 3, 1:3]))\n\n      invisible(param)\n    }\n  } else {\n    print(paste(\"Warning: this station has less than \", GLOBAL_min_years_data,\" years of data. Use another method!\",\n                collapse = \"\", sep = \"\"))\n    invisible(param)\n  }\n\n}\n\n#' Calculating the posterior predictive distribution\n#' @description Function to calculate the posterior predictive distribution after calling gev_bayes\n#' @param (mmrp, mupars, spars, kpars) parameters returned by gev_bayes. mupars, spars, kpars are the ensemble of param$estimate\n#' @return param Estimated parameters and standard error returned as a list($estimate, $se)\n#' @export\n#'\n#' @examples Needs example\nget_posterior_gev <- function(mmrp, mupars, spars, kpars) {\n\n  qqsample1 <- sapply(seq(length(mupars)), function(st) {\n    mean_temp <- mupars[st]\n    st_temp <- spars[st]\n    k_temp <- kpars[st]\n    # param$estimate <- c(mean_temp, st_temp, k_temp)\n    nsRFA::invF.GEV(F = (1 - 1 / mmrp), mean_temp, st_temp, k_temp)\n  },simplify = \"array\")\n  # 1 is for collums only 0.5 to return the median\n  qqr <- apply(qqsample1, 1, quantile, 0.5)\n}\n\n",
    "created" : 1464719467637.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3219054051",
    "id" : "D24C4860",
    "lastKnownWriteTime" : 1464767933,
    "path" : "~/GitHub/fitdistrib/R/GEV.R",
    "project_path" : "R/GEV.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}